import{t as y,E as w,F as g,q as O,u as I,V as j,b as _,M as ee,k as te}from"./mesh-DYwoPhri.js";import{f as k,n as ne,V as F,g as re,h as se,T as ie}from"./three.module-lM_mZEoP.js";function oe(n){return n.length}function ae(n,e,t){t===void 0&&(t=-1),t===-1&&(t=n.length);for(var r=n[0]*e[0],i=1;i<t;++i)r+=n[i]*e[i];return r}function le(n){for(var e=n.length,t=n[0]*n[0],r=1;r<e-1;++r)t+=n[r]*n[r];if(t===0)return n;t=1/Math.sqrt(t);for(var r=0;r<e;++r)n[r]*=t;return n}function U(n,e,t,r,i){for(var s=0,a=0,o=0;o<i;++o)if(o!==t){a=0;for(var l=0;l<i;++l)l!==r&&(e[s][a]=n[o][l],++a);++s}}function W(n){for(var e=new ArrayBuffer(n*n*4),t=[],r=0;r<n;++r)t[r]=new Float32Array(e,r*n<<2,n);return t}function $(n,e){if(e===1)return n[0][0];if(e===2)return n[0][0]*n[1][1]-n[0][1]*n[1][0];if(e===3)return n[0][0]*n[1][1]*n[2][2]+n[0][1]*n[1][2]*n[2][0]+n[0][2]*n[1][0]*n[2][1]-n[0][2]*n[1][1]*n[2][0]-n[0][1]*n[1][0]*n[2][2]-n[0][0]*n[1][2]*n[2][1];for(var t=1,r=0,i=W(e-1),s=0;s<e;++s)U(n,i,0,s,e),r+=t*n[0][s]*$(i,e-1),t=-t;return r}function ce(n,e){var t=n[0].length;if(e=e||new Float32Array(t),t===3){var r=n[0],i=n[1],s=r[0],a=r[1],o=r[2],l=i[0],c=i[1],h=i[2];e[0]=a*h-o*c,e[1]=o*l-s*h,e[2]=s*c-a*l}else for(var f=t%2?-1:1,u=W(t-1),d=0;d<t;++d)U(n,u,t-1,d,t),e[d]=f*$(u,t-1),f=-f;return e}function H(n,e){var t=n.length,r=n[0],i=[];e=e||new Float32Array(t+1);for(var s=1;s<t;++s){for(var a=n[s],o=[],l=0;l<t;++l)o[l]=r[l]-a[l];i.push(o)}return ce(i,e),e[t]=-ae(r,e,t),le(e),e}function G(n){for(var e=n.length,t=0;t<e;++t)n[t]=-n[t];return n}function T(n,e,t){t===void 0&&(t=-1),t===-1&&(t=n.length);for(var r=e[t],i=0;i<t;++i)r+=n[i]*e[i];return r}var ue=function(){function n(e){this.verts=[],this.facet=e}return n.prototype.getPlane=function(e,t){return this._plane||(this._plane=H(this.verts.map(function(r){return e[r]})),T(t,this._plane)>0&&G(this._plane)),this._plane},n}(),J=function(){function n(){this.ridges=[],this.verts=[]}return n}();function he(n,e,t){for(var r=e.verts,i=r.length,s=0,a=t;s<a.length;s++)for(var o=a[s],l=0,c=o.ridges;l<c.length;l++){var h=c[l];if(!h.neighbor){for(var f=!0,u=0;u<i;++u)f=f&&h.verts.indexOf(r[u])>=0;if(f){e.neighbor=h,h.neighbor=e;return}}}}function K(n,e,t,r){var i=n.ridges.map(function(c){return e[c.verts[0]]}),s=n.plane=H(i);if(r&&T(r,s,t)>0){G(s),n.verts.reverse(),n.ridges.reverse();for(var a=0,o=n.ridges;a<o.length;a++){var l=o[a];l.verts.reverse()}}}function Q(n,e,t){for(var r=n.verts,i=n.ridges,s=i.length;s<t;++s){for(var a=new ue(n),o=0;o<t-1;++o)a.verts[o]=r[(s+o)%t];a.opposite=r[(s+t)%t],he(n,a,e),n.ridges.push(a)}}function fe(n,e,t,r,i,s){var a=new J;return a.verts=n.verts.concat([e]),a.ridges.push(n),n.facet=a,n.opposite=e,Q(a,r,s),K(a,t,s,i),a}function de(n,e,t){var r=e?e[0]:0,i=n[r],s=i.length,a=e?e.length:s+1;if(t)for(var o=0;o<s;++o)t[o]=i[o];else t=i.slice();for(var o=0;o<s;++o){for(var l=1;l<a;++l){var c=e?e[l]:l;t[o]+=n[c][o]}t[o]/=a}return t}function pe(n,e){for(var t=n[0].length,r=t+1,i=[],s=0;s<=t;++s){for(var a=new J,o=0;o<t;++o){var l=(s+o)%r;a.verts[o]=e?e[l]:l}Q(a,i,t);var c=(s+t)%(t+1),h=n[e?e[c]:c];K(a,n,t,h),i.push(a)}return i}function ve(n){for(var e=n.length,t,r;e!==0;)r=Math.floor(Math.random()*e),e-=1,t=n[e],n[e]=n[r],n[r]=t;return n}function me(n,e){console.assert(e<n.length,"Index out of bounds!");var t=n.pop();return n.length>0&&t!==n[e]&&(n[e]=t),e}function ge(n,e){for(var t=e.slice().sort(function(a,o){return o-a}),r=0,i=t;r<i.length;r++){var s=i[r];me(n,s)}return n}function q(n,e){var t=n.pop();if(t===e)return n.length;var r=n.indexOf(e);if(r===-1)throw n.push(t),new Error("Removing component that's not present");return n[r]=t,r}var X=1e-4,Y=function(){function n(){this.outsideSet=[],this.outsideDist=[]}return n}();function we(n){var e=n.meta,t=e.outsideSet,r=e.outsideDist,i=t.length;if(i===0)return-1;for(var s=t[0],a=r[0],o=1;o<i;++o)r[o]>a&&(a=r[o],s=t[o]);return s}function R(n,e,t,r){for(var i=t.map(function(p){return[]}),s=n.length,a=0;a<s;++a)for(var o=n[a],l=e[o],c=0,h=t;c<h.length;c++){var f=h[c],u=T(l,f.plane,r);if(u>X){var d=f.meta;d.outsideSet.push(o),d.outsideDist.push(u);break}}return i}function Z(n,e,t,r,i){t.push(e),e.meta.currentPoint=n;for(var s=0,a=e.ridges;s<a.length;s++){var o=a[s],l=o.neighbor.facet;l.meta.currentPoint!==n&&(T(n,l.plane,i)>X?Z(n,l,t,r,i):r.push(o))}}function xe(n,e,t,r,i){for(var s=[],a=0,o=t;a<o.length;a++){var l=o[a],c=fe(l,e,n,s,r,i);c.meta=new Y,s.push(c)}return s}function Fe(n,e,t,r){for(var i=t[n],s=t[e],a=0;a<r;++a){if(i[a]<s[a])return e;if(i[a]>s[a])return n}return e}function Ee(n,e,t,r){for(var i=t[n],s=t[e],a=0;a<r;++a){if(i[a]>s[a])return e;if(i[a]<s[a])return n}return e}function Te(n,e){for(var t=n.length,r=0,i=0,s=1;s<t;++s)i=Fe(s,i,n,e),r=Ee(s,r,n,e);for(var a=[r,i],o=[n[r],n[i]],s=2;s<e+1;++s){for(var l=H(o),c=-1/0,h=-1,f=0;f<t;++f){var u=Math.abs(T(n[f],l,s));u>c&&(c=u,h=f)}a.push(h),o.push(n[h])}return a}function Pe(n){var e=n.length;if(e!==0){var t=oe(n[0]);if(e<=t)throw new Error("A convex hull in "+t+" dimensions requires at least "+(t+1)+" points.");for(var r=[],i=0;i<e;++i)r.push(i);for(var s=Te(n,t),a=de(n,s),o=pe(n,s),l=0,c=o;l<c.length;l++){var h=c[l];h.meta=new Y}ge(r,s),ve(r),R(r,n,o,t);for(var f=!1;!f;){f=!0;for(var i=0;i<o.length;++i){var u=o[i],d=we(u);if(d!==-1){q(u.meta.outsideSet,d);var p=[],v=[];Z(n[d],u,p,v,t);for(var x=xe(n,d,v,a,t),E=0,N=p;E<N.length;E++){var S=N[E];q(o,S)<=i&&--i,R(S.meta.outsideSet,n,x,t),S.meta.outsideSet.length>0&&(f=!1)}o.push.apply(o,x)}}}for(var A=0,b=o;A<b.length;A++){var h=b[A];h.meta=null}return o}}function Ce({length:n=1,width:e=1,height:t=1,stack:r=1}={}){const i=Array();for(let c=0;c<16;c++)i.push(new y({position:k(((c&1)*2-1)/2*n,((c&2)-1)/2*e,((c&4)/2-1)/2*t,((c&8)/4-1)/2*r)}));const s=Array();for(let c=0;c<16;c++)for(let h=c;h<16;h++){let f=c^h;(f==1||f==2||f==4||f==8)&&s.push(new w([c,h]))}const a=[[0,1,2,3,4,5,6,7],[12,13,14,15,8,9,10,11],[0,4,2,6,8,12,10,14],[5,1,7,3,13,9,15,11],[4,5,6,7,12,13,14,15],[1,0,3,2,9,8,11,10],[2,6,3,7,10,14,11,15],[1,0,5,4,9,8,13,12]],o=[],l=[[1,0,2,3],[0,4,6,2],[4,5,7,6],[5,1,3,7],[3,2,6,7],[0,1,5,4]];return a.forEach(c=>{l.forEach(h=>{const f=new g;h.forEach(u=>{f.indice.push(c[u])}),o.push(f)})}),new O({mesh:new I({vertice:i,edges:s,faces:o})})}function De(){const n=Array();for(let r=0;r<8;r++)n.push(new j({position:_(((r&1)*2-1)/2,((r&2)-1)/2,((r&4)/2-1)/2)}));const e=Array();for(let r=0;r<8;r++)for(let i=r;i<8;i++){let s=r^i;(s==1||s==2||s==4)&&e.push(new w([r,i]))}const t=[new g({indice:[0,1,3,2]}),new g({indice:[0,2,6,4]}),new g({indice:[0,4,5,1]}),new g({indice:[2,3,7,6]}),new g({indice:[1,5,7,3]}),new g({indice:[4,6,7,5]})];return new ee({mesh:new te({vertice:n,edges:e,faces:t})})}function Oe(n){const e=Array();for(let o=0;o<16;o++)e.push(k(((o&1)*2-1)/2,((o&2)-1)/2,((o&4)/2-1)/2,((o&8)/4-1)/2));const t=[[0,1,2,3,4,5,6,7],[12,13,14,15,8,9,10,11],[0,4,2,6,8,12,10,14],[5,1,7,3,13,9,15,11],[4,5,6,7,12,13,14,15],[1,0,3,2,9,8,11,10],[2,6,3,7,10,14,11,15],[1,0,5,4,9,8,13,12]],r=Array();n?t.forEach((o,l)=>{o.forEach(c=>{r.push(new y({position:e[c],color:n[l]}))})}):t.forEach((o,l)=>{o.forEach(c=>{r.push(new y({position:e[c]}))})});const i=[],s=[[1,0,2,3],[0,4,6,2],[4,5,7,6],[5,1,3,7],[3,2,6,7],[0,1,5,4]];t.forEach((o,l)=>{s.forEach(c=>{const h=new g,f=l*8;c.forEach(u=>{h.indice.push(u+f)}),i.push(h)})});const a=Array();return i.forEach(o=>{for(let l=0;l+1<o.indice.length;l++)a.push(new w([o.indice[l],o.indice[l+1]]));o.indice.length>2&&a.push(new w([o.indice[o.indice.length-1],o.indice[0]]))}),new O({mesh:new I({vertice:r,edges:a,faces:i})})}function Ie({radius_x:n=1,radius_y:e=1,radius_z:t=1,radius_w:r=1}={}){const i=[];for(let l=0;l<500;++l){const c=P(0,1),h=P(0,1),f=P(0,1),u=P(0,1),d=k(c,h,f,u);ne(d,d),d[0]*=n,d[1]*=e,d[2]*=t,d[3]*=r,i.push(d)}const s=Pe(i),a=[];i.forEach(l=>{a.push(new y({position:l}))});const o=[];return s.forEach(l=>{o.push(new w([l.verts[0],l.verts[1]])),o.push(new w([l.verts[1],l.verts[2]])),o.push(new w([l.verts[2],l.verts[3]])),o.push(new w([l.verts[3],l.verts[0]]))}),new O({mesh:new I({vertice:a,edges:o})})}function P(n,e){const t=Math.random(),r=Math.random(),i=Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*r);return n+e*i}const V=0,Me=1,Ve=new F,z=new re,C=new se,L=new F,M=new ie;class ke{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new B,this.unassigned=new B,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.vertices.push(new ye(e[t]));this.compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(r){const i=r.geometry;if(i!==void 0){const s=i.attributes.position;if(s!==void 0)for(let a=0,o=s.count;a<o;a++){const l=new F;l.fromBufferAttribute(s,a).applyMatrix4(r.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let r=0,i=t.length;r<i;r++)if(t[r].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const r=this.faces;let i=-1/0,s=1/0;for(let a=0,o=r.length;a<o;a++){const l=r[a],c=l.distanceToPoint(e.origin),h=l.normal.dot(e.direction);if(c>0&&h>=0)return null;const f=h!==0?-c/h:0;if(!(f<=0)&&(h>0?s=Math.min(f,s):i=Math.max(f,i),i>s))return null}return i!==-1/0?e.at(i,t):e.at(s,t),t}intersectsRay(e){return this.intersectRay(e,Ve)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let r=e.outside;for(;r.next!==null&&r.next.face===e;)r=r.next;return this.assigned.removeSubList(t,r),t.prev=r.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const r=this.removeAllVerticesFromFace(e);if(r!==void 0)if(t===void 0)this.unassigned.appendChain(r);else{let i=r;do{const s=i.next;t.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,t):this.unassigned.append(i),i=s}while(i!==null)}return this}resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const r=t.next;let i=this.tolerance,s=null;for(let a=0;a<e.length;a++){const o=e[a];if(o.mark===V){const l=o.distanceToPoint(t.point);if(l>i&&(i=l,s=o),i>1e3*this.tolerance)break}}s!==null&&this.addVertexToFace(t,s),t=r}while(t!==null)}return this}computeExtremes(){const e=new F,t=new F,r=[],i=[];for(let s=0;s<3;s++)r[s]=i[s]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let s=0,a=this.vertices.length;s<a;s++){const o=this.vertices[s],l=o.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),r[c]=o);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),i[c]=o)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:r,max:i}}computeInitialHull(){const e=this.vertices,t=this.computeExtremes(),r=t.min,i=t.max;let s=0,a=0;for(let u=0;u<3;u++){const d=i[u].point.getComponent(u)-r[u].point.getComponent(u);d>s&&(s=d,a=u)}const o=r[a],l=i[a];let c,h;s=0,z.set(o.point,l.point);for(let u=0,d=this.vertices.length;u<d;u++){const p=e[u];if(p!==o&&p!==l){z.closestPointToPoint(p.point,!0,L);const v=L.distanceToSquared(p.point);v>s&&(s=v,c=p)}}s=-1,C.setFromCoplanarPoints(o.point,l.point,c.point);for(let u=0,d=this.vertices.length;u<d;u++){const p=e[u];if(p!==o&&p!==l&&p!==c){const v=Math.abs(C.distanceToPoint(p.point));v>s&&(s=v,h=p)}}const f=[];if(C.distanceToPoint(h.point)<0){f.push(m.create(o,l,c),m.create(h,l,o),m.create(h,c,l),m.create(h,o,c));for(let u=0;u<3;u++){const d=(u+1)%3;f[u+1].getEdge(2).setTwin(f[0].getEdge(d)),f[u+1].getEdge(1).setTwin(f[d+1].getEdge(0))}}else{f.push(m.create(o,c,l),m.create(h,o,l),m.create(h,l,c),m.create(h,c,o));for(let u=0;u<3;u++){const d=(u+1)%3;f[u+1].getEdge(2).setTwin(f[0].getEdge((3-u)%3)),f[u+1].getEdge(0).setTwin(f[d+1].getEdge(1))}}for(let u=0;u<4;u++)this.faces.push(f[u]);for(let u=0,d=e.length;u<d;u++){const p=e[u];if(p!==o&&p!==l&&p!==c&&p!==h){s=this.tolerance;let v=null;for(let x=0;x<4;x++){const E=this.faces[x].distanceToPoint(p.point);E>s&&(s=E,v=this.faces[x])}v!==null&&this.addVertexToFace(p,v)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const r=this.faces[t];r.mark===V&&e.push(r)}return this.faces=e,this}nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const r=this.assigned.first().face;let i=r.outside;do{const s=r.distanceToPoint(i.point);s>t&&(t=s,e=i),i=i.next}while(i!==null&&i.face===r);return e}}computeHorizon(e,t,r,i){this.deleteFaceVertices(r),r.mark=Me;let s;t===null?s=t=r.getEdge(0):s=t.next;do{const a=s.twin,o=a.face;o.mark===V&&(o.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,a,o,i):i.push(s)),s=s.next}while(s!==t);return this}addAdjoiningFace(e,t){const r=m.create(e,t.tail(),t.head());return this.faces.push(r),r.getEdge(-1).setTwin(t.twin),r.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let r=null,i=null;for(let s=0;s<t.length;s++){const a=t[s],o=this.addAdjoiningFace(e,a);r===null?r=o:o.next.setTwin(i),this.newFaces.push(o.face),i=o}return r.next.setTwin(i),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();(e=this.nextVertexToAdd())!==void 0;)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}class m{constructor(){this.normal=new F,this.midpoint=new F,this.area=0,this.constant=0,this.outside=null,this.mark=V,this.edge=null}static create(e,t,r){const i=new m,s=new D(e,i),a=new D(t,i),o=new D(r,i);return s.next=o.prev=a,a.next=s.prev=o,o.next=a.prev=s,i.edge=s,i.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),r=this.edge.next.head();return M.set(e.point,t.point,r.point),M.getNormal(this.normal),M.getMidpoint(this.midpoint),this.area=M.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class D{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class ye{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class B{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}export{ke as C,Ce as a,Oe as b,Ie as c,De as g};
